---
layout: post
title: "ELisp crash course"
date: 2015-07-10
---

If you use Emacs but don't know Lisp, you are missing a lot. Emacs is
infinitely customizable with Emacs Lisp (ELisp). This post is an introduction
to ELisp, hopefully giving you enough basics to write useful functions.

### Basic Types

Strings are double quoted and can contain newlines. Use backslash to escape
double quotes:

{% highlight lisp %}
"This is an \"Emacs verse\"
Forgive it for being so terse"
{% endhighlight %}

The syntax for a character is `?x`: question mark followed by character. Some
need to be escaped, like for example `?\(`, `?\)` and `?\\`. Here are many
functions operating on strings, for example:

{% highlight lisp %}
(length "foo")              ; returns 3. It also works with lists.
(concat "foo" "bar" "baz")  ; returns a new string "foobarbaz"
(string= "foo" "foo")       ; string comparison
(substring "foobar" 0 3)    ; returns "foo"
(upcase "foo")              ; returns "FOO"
{% endhighlight %}

Integers have 29 bits of precision (I don't know why) and doubles have 64
bits. Binary starts with "#b" and Hexadecimal with "#x".

In Lisp an array is called a vector, and you can create one like so:
`[ "the" "answer" "is" 42]`. Like lists, they can contain objects of various
types. You use spaces to separate the values; comas are part of the Lisp syntax
but they are used for something else as we will soon see.

There are also sets and hash tables but they are not used often: most of the
time a simple list is sufficient. Since lists are so important there is a
special syntax just for them:

{% highlight lisp %}
'a               ; => a
'(a b c)         ; => (a b c)
`(1 ,(+ 1 1) 3)  ; => (1 2 3)
{% endhighlight %}

The quote prevents the evaluation of the symbol "a" on the first line, and the
list on the second line, otherwise they would be considered as a variable and a
function call respectively. The backquote is like a quote, except that any
element preceded by a coma is evaluated.

### Variables

Lisp is a dynamically-typed language, like Ruby or Python and unlike Java or
C++. You don't need to declare the type of a variable, and a variable can hold
objects of different types over time.

We already saw in the previous post how to declare a global variable with
`defvar` and set it with `setq`. Another way to use variables is function
parameters:

{% highlight lisp %}
(defun add (x y)
  (+ x y))

(message "%s + %s = %s" 1 2 (add 1 2)) ; prints "1 + 2 = 3"
{% endhighlight %}

Here we define a function `add` with 2 arguments, which returns the sum of its
arguments. Then we call it. `message` is an Emacs function similar to C's
printf: it prints a message in the mini-buffer and in the messages
buffer[^fn-minibuffer].

Every time you call `add`, Lisp creates new *bindings* to hold the values of
`x` and `y` within the scope of the function call. A single variable can have
multiple bindings at the same time; for example the parameters of a recursive
function are rebound for each call of the function.

The `let` form declares local variables. The syntax is _(let (variable*) body)_
where each variable is either a variable name, or a list _(variable-name
value)_. Variables declared with no value are bound to nil. For example:

{% highlight lisp %}
(let ((x 1)
      y)
  (message "x = %s, y = %s" x y)) ; prints "x = 1, y = nil"
{% endhighlight %}

The scope of the variable bindings is the body of the `let` form. After the
`let`, the variables refer to whatever, if anything, they referred to before
the call to `let`. You can bind the same variable multiple times:

{% highlight lisp %}
(defun foo (x)
  (message "x = %d" x)       ; x = 1
  (let ((x 2))
    (message "x = %d" x)     ; x = 2
    (let ((x 3))
      (message "x = %d" x))  ; x = 3
    (message "x = %d" x))    ; x = 2
  (message "x = %d" x))      ; x = 1

;; Check the Messages buffer to see the results
(foo 1)
{% endhighlight %}

Note that `let` binds variables in parallel and not sequentially. That means
that you cannot declare a variable whose value depends on another variable
declared in the same let. For example this is wrong:

{% highlight lisp %}
(let ((x 1)
      (y (* x 10)))
  (message "x = %s, y = %s" x y)) ; error: variable x is void
{% endhighlight %}

There are two ways to fix the code above: you could use a second `let` within
the first, or you could replace `let` with `let*`: it binds variables
sequentially, one after the other. The key to understand that is to remember
that the origin of Lisp is the
[Lamda Calculus](https://en.wikipedia.org/wiki/Lambda_calculus), where
everything is a function call. The first `let` form above is equivalent to
calling an anonymous function like this:

{% highlight lisp %}
;; equivalent to (let ((x 1) y) (message ...))
;; prints "x = 1, y = nil"
((lambda (x y)
   (message "x = %s, y = %s" x y))
 1 nil)
{% endhighlight %}

Here we define a *lambda* (anonymous) function with 2 arguments, and we call it
with the values of the arguments. The syntax of a lambda is _(lambda
(arguments*) body)_, and we call it like any other function by putting it in a
second pair of parentheses with the arguments.

The equivalent of a `let*` requires multiple function calls:

{% highlight lisp %}
;; equivalent to (let* ((x 10) (y x)) (message ...))
;; prints "x = 1, y = 10"
((lambda (x)
   ((lambda (y)
      (message "x = %s, y = %s" x y))
    (* x 10)))
 1)
{% endhighlight %}

The first lambda binds x to 1 and the second lambda binds y to x * 10.

[^fn-minibuffer]: A right click in the mini-buffer pops up the message buffer. That's a nice trick for debugging if you have a lot of traces.
